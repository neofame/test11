https://andrewlock.net/a-look-behind-the-jwt-bearer-authentication-middleware-in-asp-net-core/
https://auth0.com/blog/how-to-validate-jwt-dotnet/
https://docs.servicestack.net/auth/jwt-identity-auth#authenticating-with-jwt

https://devforum.okta.com/t/asp-net-automatic-redirect-owin-configuration/16633
app.UseCookieAuthentication(new CookieAuthenticationOptions {
            AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,
            LoginPath = new PathString("/Account/Login"),

https://bitoftech.net/2014/06/01/token-based-authentication-asp-net-web-api-2-owin-asp-net-identity/comment-page-4/

https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-8.0
https://github.com/dotarj/protobuf-net-data

https://www.codeproject.com/Articles/5382064/gRPC-NET-8-0-and-Kestrel-in-Easy-Samples
https://medium.com/@lukastosic/part-2-grpc-its-fairly-simple-c-crud-example-f8ff3ce9bb85
https://blog.markvincze.com/include-multi-file-protobuf-package-in-dotnet/

using System;
using System.IO;
using System.IO.Pipes;

class PipeServer
{
    static void Main()
    {
        using (NamedPipeServerStream pipeServer =
            new NamedPipeServerStream("testpipe", PipeDirection.Out))
        {
            Console.WriteLine("NamedPipeServerStream object created.");

            // Wait for a client to connect
            Console.Write("Waiting for client connection...");
            pipeServer.WaitForConnection();

            Console.WriteLine("Client connected.");
            try
            {
                // Read user input and send that to the client process.
                using (StreamWriter sw = new StreamWriter(pipeServer))
                {
                    sw.AutoFlush = true;
                    Console.Write("Enter text: ");
                    sw.WriteLine(Console.ReadLine());
                }
            }
            // Catch the IOException that is raised if the pipe is broken
            // or disconnected.
            catch (IOException e)
            {
                Console.WriteLine("ERROR: {0}", e.Message);
            }
        }


using System;
using System.IO;
using System.IO.Pipes;

class PipeClient
{
    static void Main(string[] args)
    {
        using (NamedPipeClientStream pipeClient =
            new NamedPipeClientStream(".", "testpipe", PipeDirection.In))
        {

            // Connect to the pipe or wait until the pipe is available.
            Console.Write("Attempting to connect to pipe...");
            pipeClient.Connect();

            Console.WriteLine("Connected to pipe.");
            Console.WriteLine("There are currently {0} pipe server instances open.",
               pipeClient.NumberOfServerInstances);
            using (StreamReader sr = new StreamReader(pipeClient))
            {
                // Display the read text to the console
                string temp;
                while ((temp = sr.ReadLine()) != null)
                {
                    Console.WriteLine("Received from server: {0}", temp);
                }
            }
        }
        Console.Write("Press Enter to continue...");
        Console.ReadLine();
    }
}
    }
}








17

통화 기한을 설정하려면 다음 "기한"을 사용하면 됩니다.

client.Classify(featureSet, deadline: DateTime.UtcNow.AddSeconds(5));
또는

client.Classify(featureSet, new CallOptions(deadline: DateTime.UtcNow.AddSeconds(5)));
두 가지 방법 모두 코드 완성을 통해 쉽게 검색할 수 있어야 합니다.

공유
이 답변 개선
뒤따르다
2016 년 6 월 9 일 18:17에 편집 됨
MazeCreator의 사용자 아바타
미로창조자
5531골드 배지 1개12실버 배지 12개28브론즈 배지 28개
2016 년 6 월 7 일 23:03에 대답
Jan Tattermusch의 사용자 아바타
얀 타테르무쉬(Jan Tattermusch)
1,65310실버 배지 10개10브론즈 배지 10개
고마워요, 내 개발 플랫폼에는 외부 라이브러리에 대한 코드 완성 기능이 없습니다. 이것은 약간의 수정으로 작동했습니다. 
– 
미로창조자
 댓글을 달았습니다2016년 6월 9일 17:24
클라이언트. 분류(기능 설정, 마감일: DateTime.UtcNow.AddSeconds(5)); UtcNow 뒤에서 ()를 제거했습니다. 
– 
미로창조자
 댓글을 달았습니다2016년 6월 9일 17:24
4
이 답변은 구식 인 것 같으며 현재 버전에는 Classify가 없습니다. 
– 
뚱뚱한 사람
 댓글을 달았습니다2019년 6월 1일 9:09
6
Classify는 예제일 뿐입니다. 따라서 myGrpcClient.MyCall(someParam, deadline: DateTime.UtcNow.AddSeconds(5)); 
– 
샌더
 댓글을 달았습니다2019년 11월 22일 13:58
한 번 시간 초과. 예외 ( RpcException )가 발생합니까? 
– 
프 렘
 댓글을 달았습니다2020년 10월 6일 5:00
댓글 추가
11

서버 다운 시나리오를 탐지하기 위한 GRPC 시간 초과는 채널을 연결하기 위해 통화에 사용해야 합니다. 나는 이렇게했다.

    private async void SampleCode()
     {
          var client = await GetClient();
          var data = await client.GetAllTemplatesAsync(request, new 
                CallOptions().WithDeadline(DateTime.UtcNow.AddSeconds(7)));

     }

    private async Task<MyGrpcClient> GetClient()
    {
        var channel = new Channel("somehost",23456, ChannelCredentials.Insecure);
        await channel.ConnectAsync(deadline: DateTime.UtcNow.AddSeconds(2));
        return new MyGrpcClient(channel);
    }
따라서 서버가 다운되면 GetClient()에 대한 호출이 시간 초과됩니다. 서버가 작동 중이지만 응답이 너무 오래 걸리는 경우 클라이언트 서비스 호출의 시간 초과가 적용됩니다.

공유
이 답변 개선
뒤따르다

     byte[] byteKey = File.ReadAllBytes(fole);

     X509Certificate2 xcerty = new X509Certificate2(fole,"leopard00==");


     byte[] rawdata = xcerty.RawData;
     Console.WriteLine("Content Type: {0}{1}", X509Certificate2.GetCertContentType(rawdata), Environment.NewLine);
     Console.WriteLine("Friendly Name: {0}{1}", xcerty.FriendlyName, Environment.NewLine);
     Console.WriteLine("Certificate Verified?: {0}{1}", xcerty.Verify(), Environment.NewLine);
     Console.WriteLine("Simple Name: {0}{1}", xcerty.GetNameInfo(X509NameType.SimpleName, true), Environment.NewLine);
     Console.WriteLine("Signature Algorithm: {0}{1}", xcerty.SignatureAlgorithm.FriendlyName, Environment.NewLine);
     Console.WriteLine("Public Key: {0}{1}", xcerty.PublicKey.Key.ToXmlString(false), Environment.NewLine);
     Console.WriteLine("Certificate Archived?: {0}{1}", xcerty.Archived, Environment.NewLine);
     Console.WriteLine("Length of Raw Data: {0}{1}", xcerty.RawData.Length, Environment.NewLine);





     EncryptFile(originalFile, (RSA)xcerty.PublicKey.Key);
     DecryptFile(encryptedFile, (RSA)xcerty.GetRSAPrivateKey());




     string original = "Here is some data to encrypt!";

     // Create a new instance of the Aes
     // class.  This generates a new key and initialization
     // vector (IV).
     using (Aes myAes = Aes.Create())
     {

         // Encrypt the string to an array of bytes.
         byte[] encrypted = EncryptStringToBytes_Aes(original, myAes.Key, myAes.IV);
         //    string aaa = Encoding.ASCII.GetString(encrypted);


         string s = Convert.ToBase64String(encrypted);
         Console.WriteLine("The base 64 string:\n   {0}\n", s);

         // Restore the byte array.

         string utf8 = DecryptStringFromBytes_Aes(Convert.FromBase64String(s), myAes.Key, myAes.IV);

       //  string ascii = DecryptStringFromBytes_Aes(Encoding.Default.GetBytes(bbb), myAes.Key, myAes.IV);

         // Decrypt the bytes to a string.
         string roundtrip = DecryptStringFromBytes_Aes(encrypted, myAes.Key, myAes.IV);

         //Display the original data and the decrypted data.
         Console.WriteLine("Original:   {0}", original);
         Console.WriteLine("Round Trip: {0}", roundtrip);
     }


      

     //X509Certificate2UI.DisplayCertificate(xcerty);

     // Create an input file with test data.
     //StreamWriter sw = File.CreateText(""originalFile"");
     //sw.WriteLine("Test data to be encrypted");
     //sw.Close();

     // Get the certificate to use to encrypt the key.
     X509Certificate2 cert = GetCertificateFromStore(@"d:\tmp\signCert.der");

     if (cert == null)
     {
         Console.WriteLine("Certificate 'CN=CERT_SIGN_TEST_CERT' not found.");
         Console.ReadLine();
     }
     string baseAddress = "http://localhost:9090/";

     // Start OWIN host
     IDisposable signalR = null;
     signalR = WebApp.Start<Startup>(url: baseAddress);
     // using ()
     {
         // Create HttpCient and make a request to api/values
         HttpClient client = new HttpClient();

        // HttpResponseMessage response = client.GetAsync(baseAddress + "api/values").Result;
         HttpResponseMessage response = client.GetAsync(baseAddress + "Customer/1").Result;
         

         Console.WriteLine(response);
         Console.WriteLine(response.Content.ReadAsStringAsync().Result);
     }



     Console.ReadLine();
 }



 static byte[] EncryptStringToBytes_Aes(string plainText, byte[] Key, byte[] IV)
 {
     // Check arguments.
     if (plainText == null || plainText.Length <= 0)
         throw new ArgumentNullException("plainText");
     if (Key == null || Key.Length <= 0)
         throw new ArgumentNullException("Key");
     if (IV == null || IV.Length <= 0)
         throw new ArgumentNullException("IV");
     byte[] encrypted;

     // Create an Aes object
     // with the specified key and IV.
     using (Aes aesAlg = Aes.Create())
     {
         aesAlg.Key = Key;
         aesAlg.IV = IV;

         // Create an encryptor to perform the stream transform.
         ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

         // Create the streams used for encryption.
         using (MemoryStream msEncrypt = new MemoryStream())
         {
             using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
             {
                 using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                 {
                     //Write all data to the stream.
                     swEncrypt.Write(plainText);
                 }
                 encrypted = msEncrypt.ToArray();
             }
         }
     }

     // Return the encrypted bytes from the memory stream.
     return encrypted;
 }

 static string DecryptStringFromBytes_Aes(byte[] cipherText, byte[] Key, byte[] IV)
 {
     // Check arguments.
     if (cipherText == null || cipherText.Length <= 0)
         throw new ArgumentNullException("cipherText");
     if (Key == null || Key.Length <= 0)
         throw new ArgumentNullException("Key");
     if (IV == null || IV.Length <= 0)
         throw new ArgumentNullException("IV");

     // Declare the string used to hold
     // the decrypted text.
     string plaintext = null;

     // Create an Aes object
     // with the specified key and IV.
     using (Aes aesAlg = Aes.Create())
     {
         aesAlg.Key = Key;
         aesAlg.IV = IV;

         // Create a decryptor to perform the stream transform.
         ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

         // Create the streams used for decryption.
         using (MemoryStream msDecrypt = new MemoryStream(cipherText))
         {
             using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
             {
                 using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                 {

                     // Read the decrypted bytes from the decrypting stream
                     // and place them in a string.
                     plaintext = srDecrypt.ReadToEnd();
                 }
             }
         }
     }

     return plaintext;
 }

