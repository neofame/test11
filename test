https://andrewlock.net/a-look-behind-the-jwt-bearer-authentication-middleware-in-asp-net-core/
https://auth0.com/blog/how-to-validate-jwt-dotnet/
https://docs.servicestack.net/auth/jwt-identity-auth#authenticating-with-jwt

https://devforum.okta.com/t/asp-net-automatic-redirect-owin-configuration/16633
app.UseCookieAuthentication(new CookieAuthenticationOptions {
            AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,
            LoginPath = new PathString("/Account/Login"),

https://bitoftech.net/2014/06/01/token-based-authentication-asp-net-web-api-2-owin-asp-net-identity/comment-page-4/

https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-8.0
https://github.com/dotarj/protobuf-net-data


using System;
using System.IO;
using System.IO.Pipes;

class PipeServer
{
    static void Main()
    {
        using (NamedPipeServerStream pipeServer =
            new NamedPipeServerStream("testpipe", PipeDirection.Out))
        {
            Console.WriteLine("NamedPipeServerStream object created.");

            // Wait for a client to connect
            Console.Write("Waiting for client connection...");
            pipeServer.WaitForConnection();

            Console.WriteLine("Client connected.");
            try
            {
                // Read user input and send that to the client process.
                using (StreamWriter sw = new StreamWriter(pipeServer))
                {
                    sw.AutoFlush = true;
                    Console.Write("Enter text: ");
                    sw.WriteLine(Console.ReadLine());
                }
            }
            // Catch the IOException that is raised if the pipe is broken
            // or disconnected.
            catch (IOException e)
            {
                Console.WriteLine("ERROR: {0}", e.Message);
            }
        }


using System;
using System.IO;
using System.IO.Pipes;

class PipeClient
{
    static void Main(string[] args)
    {
        using (NamedPipeClientStream pipeClient =
            new NamedPipeClientStream(".", "testpipe", PipeDirection.In))
        {

            // Connect to the pipe or wait until the pipe is available.
            Console.Write("Attempting to connect to pipe...");
            pipeClient.Connect();

            Console.WriteLine("Connected to pipe.");
            Console.WriteLine("There are currently {0} pipe server instances open.",
               pipeClient.NumberOfServerInstances);
            using (StreamReader sr = new StreamReader(pipeClient))
            {
                // Display the read text to the console
                string temp;
                while ((temp = sr.ReadLine()) != null)
                {
                    Console.WriteLine("Received from server: {0}", temp);
                }
            }
        }
        Console.Write("Press Enter to continue...");
        Console.ReadLine();
    }
}
    }
}








17

통화 기한을 설정하려면 다음 "기한"을 사용하면 됩니다.

client.Classify(featureSet, deadline: DateTime.UtcNow.AddSeconds(5));
또는

client.Classify(featureSet, new CallOptions(deadline: DateTime.UtcNow.AddSeconds(5)));
두 가지 방법 모두 코드 완성을 통해 쉽게 검색할 수 있어야 합니다.

공유
이 답변 개선
뒤따르다
2016 년 6 월 9 일 18:17에 편집 됨
MazeCreator의 사용자 아바타
미로창조자
5531골드 배지 1개12실버 배지 12개28브론즈 배지 28개
2016 년 6 월 7 일 23:03에 대답
Jan Tattermusch의 사용자 아바타
얀 타테르무쉬(Jan Tattermusch)
1,65310실버 배지 10개10브론즈 배지 10개
고마워요, 내 개발 플랫폼에는 외부 라이브러리에 대한 코드 완성 기능이 없습니다. 이것은 약간의 수정으로 작동했습니다. 
– 
미로창조자
 댓글을 달았습니다2016년 6월 9일 17:24
클라이언트. 분류(기능 설정, 마감일: DateTime.UtcNow.AddSeconds(5)); UtcNow 뒤에서 ()를 제거했습니다. 
– 
미로창조자
 댓글을 달았습니다2016년 6월 9일 17:24
4
이 답변은 구식 인 것 같으며 현재 버전에는 Classify가 없습니다. 
– 
뚱뚱한 사람
 댓글을 달았습니다2019년 6월 1일 9:09
6
Classify는 예제일 뿐입니다. 따라서 myGrpcClient.MyCall(someParam, deadline: DateTime.UtcNow.AddSeconds(5)); 
– 
샌더
 댓글을 달았습니다2019년 11월 22일 13:58
한 번 시간 초과. 예외 ( RpcException )가 발생합니까? 
– 
프 렘
 댓글을 달았습니다2020년 10월 6일 5:00
댓글 추가
11

서버 다운 시나리오를 탐지하기 위한 GRPC 시간 초과는 채널을 연결하기 위해 통화에 사용해야 합니다. 나는 이렇게했다.

    private async void SampleCode()
     {
          var client = await GetClient();
          var data = await client.GetAllTemplatesAsync(request, new 
                CallOptions().WithDeadline(DateTime.UtcNow.AddSeconds(7)));

     }

    private async Task<MyGrpcClient> GetClient()
    {
        var channel = new Channel("somehost",23456, ChannelCredentials.Insecure);
        await channel.ConnectAsync(deadline: DateTime.UtcNow.AddSeconds(2));
        return new MyGrpcClient(channel);
    }
따라서 서버가 다운되면 GetClient()에 대한 호출이 시간 초과됩니다. 서버가 작동 중이지만 응답이 너무 오래 걸리는 경우 클라이언트 서비스 호출의 시간 초과가 적용됩니다.

공유
이 답변 개선
뒤따르다



